#!/usr/bin/perl -w

#
# Copyright (c) 2008 Rainer Clasen
#
# This program is free software; you can redistribute it and/or modify
# it under the terms described in the file LICENSE included in this
# distribution.
#

=head1 NAME

nspamper - daemon to update dynamic DNS names

=head1 SYNOPSIS

 nspamper <options>

=head1 DESCRIPTION

This is a bind9 nsupdate client to keep a dynamic A record up to date

Changes must be triggered using L<nspamper-change> which writes the new IP
to a UNIX Socket. Permissions to this socket determin who's able to
submitt new IPs.

This daemon will retry to send the update until the Nameserver returns the
proper IP. Updates and IP verification are directly sent to the Nameserver
listed in the Zone's SOA.

Once the update was successfull, this script assumes, the server won't
forget the IP and therefor sleeps until the IP is changed again.

This has to run as daemon, to avoid problems with overlapping requests.
That means it gracefully accepts a new IP although the current one wasn't
accepted by the nameserver, yet.

=head1 OPTIONS

=over 4

=item B<--config>=I<config>

Config file to read hostname and tsig key from. See FILES for details.

=item B<--[no]daemon>

Do (not) detach from tty.

=item B<--help>

Displays short usage info.

=item B<--key>=I<key-string>

TSIG key string. BEWARE: this will show up within ps. Please use the
config file for this.

=item B<--name>=I<hostname>

Dyndns hostname to take care of.

=item B<--pidfile>=I<pidfile-path>

Pidfile name.

=item B<--socketpath>=I<socket-path>

Alternative path for unix socket to listen on. Make sure you use the same
path for nspamper-change.

=item B<--statusfile>=I<status-file>

File to store status information in.

=back

=cut


use strict;
use Sys::Syslog;
use Socket;
use POSIX;
use Nspamper;
use Getopt::Long;


our $VERSION = "0.0.7";
my $prog = "nspamper";

my $daemon = 1;
my $conf = "/etc/$prog.conf";
my $ostatusfile = "/var/lib/misc/$prog.ip";
my $osocketpath = "/var/run/$prog.sock";
my $opidfile = "/var/run/$prog.pid";
my $oname;
my $okey;

my $wanthelp;
my $needhelp;

GetOptions(
	"config=s"	=> \$conf,
	"daemon!"	=> \$daemon,
	"help|h!"	=> \$wanthelp,
	"key=s"		=> \$okey,
	"name=s"	=> \$oname,
	"pidfile=s"	=> \$opidfile,
	"socketpath=s"	=> \$osocketpath,
	"statusfile=s"	=> \$ostatusfile,
) || $needhelp++;

if( $wanthelp ){
	print <<EOF;
usage: $0 [<options> ...]
client daemon for dynaimc DNS / nsupdates

options:
 --config=<conf>      config file
 --[no]daemon         do (not) detach from tty
 --help|-h            this info
 --key=<key>          TSIG key - be careful, discloses private key!!!
 --name=<host>        hostname
 --pidfile=<file>     where to record the process ID
 --socketpath=<sock>  path for unix socket to listen on
 --statusfile=<file>  file to keep status information in (last known IP)

EOF
	exit 0;
}

if( $needhelp ){
	print STDERR "use $0 --help for usage info\n";
	exit 0
}

# read config
our( $statusfile, $socketpath, $pidfile, $name, $key );
if( -r $conf ){
	do $conf;
}

# set defaults / cmdline
$statusfile ||= $ostatusfile;
$socketpath ||= $osocketpath;
$pidfile ||= $opidfile;
$name ||= $oname;
$key ||= $okey;

unless( $name =~ /^[a-z][\w.]+$/ ){
	print STDERR "invalid name: $name\n";
	exit 1;
}

unless( $key =~ /^\S+==$/ ){
	print STDERR "invalid TSIG key: $key\n";
	exit 1;
}

# daemonize
use vars qw( $cleanup );
our $terminate;

if( $daemon ){
	# TODO: close STDERR, detach tty

	my $pid = fork;
	if( $pid < 0 ){
		print STDERR "fork() failed: $!\n";
		exit 1;

	} elsif( $pid > 0 ){
		exit 0;
	}
}


openlog( $prog, "pid", "daemon" );
syslog( "info", "starting for hostname $name" );
&pidfile( $pidfile ) or exit 1;

$cleanup++;
END {
	if( $cleanup ){
		syslog( "info", "exiting" );
		close SOCK;
		unlink $socketpath;
		unlink $pidfile;
	}
}

$SIG{INT} = $SIG{TERM} = sub {
	syslog( "info", "got SIG$_[0]" );
	$terminate++;
};


unlink $socketpath;
if( ! socket( SOCK, PF_UNIX, SOCK_STREAM, 0 )){
	syslog( "err", "failed to open socket: $!" );
	exit 1;
}
if( ! bind( SOCK, sockaddr_un($socketpath)) ){
	syslog( "err", "failed to bind socket: $!" );
	exit 1;
}
chmod( 0770, $socketpath );
if( ! listen( SOCK, SOMAXCONN) ){
	syslog( "err", "failedt to listen: $!");
	exit 1;
}

my $wip = &read_ip;
$wip && syslog( "debug", "old IP: $wip");

my $timeout = undef; # TODO: configurable
while(1){
	last if $terminate;

	if( ! $wip ){
		syslog( "info", "IP is not yet known" );
		goto GETIP;
	}

	my( $dom, $ns ) = &Nspamper::get_domdat( $name ) or next;

	my $cip = &Nspamper::get_ip( $ns, $name ) || "";
	if( ! $cip or $cip ne $wip ){
		syslog( "debug", "current IP: $cip");
		if( &Nspamper::set_ip( $ns, $dom, $key, $name, $wip ) ){
			$timeout = undef;
		} else {
			$timeout = 10;
		}
	}

GETIP:
	my $nip = &wait_newip( $timeout );
	if( $nip ){
		$wip = $nip;
		syslog( "info", "new IP: $wip");
		&write_ip( $wip );
	}
}

# remember IP for restart
sub write_ip {
	my( $ip ) = @_;

	syslog( "info", "remembering new IP");
	local *F;
	if( ! open( F, ">", $statusfile) ){
		syslog( "err", "failed to write IP: $!" );
		return;
	}
	print F "$ip\n";
	close F;
}

sub is_ip {
	my $in = shift
		or return;

	my @q = ( $in =~ /^(\d+)\.(\d+)\.(\d+)\.(\d+)$/ )
		or return;

	foreach my $b( @q ){
		return unless defined $b;
		return if $b > 255;
	}
	return 1;

}

# read stored IP on startup
sub read_ip {
	local *F;
	open( F, "<", $statusfile ) or return;
	my $ip = <F>;
	close F;

	chomp $ip;
	&is_ip($ip)
		or return;
	return $ip;
}

# wait until we get a new IP
sub wait_newip {
	my( $timeout ) = @_;

	syslog( "debug", "waiting for IP change" ) unless $timeout;

	my $rin = '';
	vec( $rin, fileno(SOCK), 1 ) = 1;
	if( 0 >= select( $rin, undef, undef, $timeout ) ){
		return;
	}

	if( ! accept( CLIENT, SOCK) ){
		syslog( "err", "accept failed: $!" );
		return;
	}

	my $ip = <CLIENT>;
	close CLIENT;

	chomp $ip;
	return $ip if &is_ip($ip);

	syslog( "notice", "ignoring invalid IP" );
	return undef;
}


sub pidfile {
	my $file = shift;

	my $pid = $$;
	local *FH;
	if( open( FH, "<", $file )){
		# lockfile exists!

		my $oldpid = <FH>;
		close(FH);
		chomp $oldpid;

		if( ($oldpid =~ /^\d+$/) && ! kill 0, $oldpid ){
			syslog( "info", "overriding stale lockfile");
			unlink( $file );

		} else {
			syslog( "err", "already runing with PID $oldpid");
			return;
		}
	}

	# TODO: use Proc::PID::File
	if( ! sysopen(FH, $file, O_WRONLY | O_EXCL | O_CREAT, 0644) ){
		syslog( "err", "cannot create pidfile $file: $!" );
		return;
	}

	print FH $pid, "\n";
	close FH;

	return 1;
}


=head1 FILES

/etc/nspamper.conf - config file. Uses perl syntax. The following settings
are known:

=over 4

=item B<$key> = 'I<...tsig key...>';

TSIG key as generated with:

 dnssec-keygen  -a HMAC-MD5 -b 512 -n USER <hostname>

They look like:

 abcdefghijklmnpfsuwjfsafjewuioglkgjosperjgfkcsigrekglfdgoegjfdsgisohruahfuiafduafdaasu==

=item B<$name> = 'I<host.dyn.example.org>';

Hostname to update.

=item B<$pidfile> = 'I<pidfile-path>';

Pidfile name.

=item B<$socketpath> = 'I<socket-path>';

Alternative path for unix socket to listen on. Make sure you use the same
path for nspamper-change.

=item B<$statusfile> = 'I<status-file>';

File to store status information in.

=back

=head1 BUGS

Search the source for "TODO" to find some, but I bet there are plenty
more.

=head1 AUTHOR

Rainer Clasen E<lt>rc@zuto.deE<gt>

=head1 SEE ALSO

L<nspamper-change>, L<nsupdate>.

=cut

__END__

TODO: use several NS
TODO: add TXT records with timestamp for zone sync conflict resolution

- get_ns()
  - get _version._nspamper.<domain> TXT
  - get <domain> SOA (no version)
  - get _ns._nspamper.<domain> A? SRV? (version 1)

- get_update_ns()
  - foreach get_ns()
    - if( ! $ns->already_done )
      - get <hostname> A
      - if( ! $ns->matches )
        - push @update_ns, $ns

- update_ns()
  - update A and TXT record (with timestamp)

- foreach( get_update_ns ){
  - if( ! update_ns( $ns ) )
    - $timeout = 10;

- wait( $newip, $timeout )



