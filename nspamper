#!/usr/bin/perl -w

#
# Copyright (c) 2008 Rainer Clasen
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms described in the file LICENSE included in this
# distribution.
#

=head1 NAME

nspamper - daemon to update dynamic DNS names

=head1 SYNOPSIS

 nspamper

=head1 DESCRIPTION

This is a bind9 nsupdate client to keep a dynamic A record up to date

Changes must be triggered using L<nspamper-change> which writes the new IP
to a UNIX Socket.

This daemon will retry to send the update until the Nameserver returns the
proper IP.

Once the update was successfull, this script assumes, the server won't
forget the IP and therefor sleeps until the IP is changed again.

This has to run as daemon, to avoid problems with overlapping requests. That means it gracefully accepts a new IP although the current one wasn't accepted by the nameserver.

=cut

# TODO: explain config

use strict;
use Sys::Syslog;
use Socket;
use POSIX;
use Nspamper;

# TODO: getopt

my $prog = "nspamper";
my $ipfile = "/var/lib/misc/$prog.ip";
my $sock = "/var/run/$prog.sock";
my $pidfile = "/var/run/$prog.pid";
my $conf = "/etc/$prog.conf";

our $VERSION = "0.0.5";

# read config
-r $conf or die "missing config: $conf";
use vars qw( $name $key );
do $conf;
#$name = "warp.dyn.zuto.de";
#$key = 'blah==';

unless( $name =~ /\.(.*)/ ){
	print STDERR "invalid name: $name\n";
	exit 1;
}


# daemonize
use vars qw( $cleanup );

my $pid = fork;
if( $pid < 0 ){
	print STDERR "fork() failed: $!\n";
	exit 1;

} elsif( $pid > 0 ){
	exit 0;
}


# TODO: close STDERR, detach tty

openlog( $prog, "pid", "daemon" );
syslog( "info", "starting" );
&pidfile( $pidfile ) or exit 1;

$cleanup++;
END {
	if( $cleanup ){
		syslog( "info", "exiting" );
		close SOCK;
		unlink $sock;
		unlink $pidfile;
	}
}

# TODO: catch SIGINT and SIGTERM

unlink $sock;
if( ! socket( SOCK, PF_UNIX, SOCK_STREAM, 0 )){
	syslog( "err", "failed to open socket: $!" );
	exit 1;
}
if( ! bind( SOCK, sockaddr_un($sock)) ){
	syslog( "err", "failed to bind socket: $!" );
	exit 1;
}
chmod( 0770, $sock );
if( ! listen( SOCK, SOMAXCONN) ){
	syslog( "err", "failedt to listen: $!");
	exit 1;
}

my $wip = &read_ip;
syslog( "debug", "old IP: $wip") if defined $wip;

=pod

TODO: use several NS
TODO: add TXT records with timestamp for zone sync conflict resolution

- get_ns()
  - get _version._nspamper.<domain> TXT
  - get <domain> SOA (no version)
  - get _ns._nspamper.<domain> A? SRV? (version 1)

- get_update_ns()
  - foreach get_ns()
    - if( ! $ns->already_done )
      - get <hostname> A
      - if( ! $ns->matches )
        - push @update_ns, $ns

- update_ns()
  - update A and TXT record (with timestamp)

- foreach( get_update_ns ){
  - if( ! update_ns( $ns ) )
    - $timeout = 10;

- wait( $newip, $timeout )

=cut

my $timeout = undef;
while(1){

	if( ! $wip ){
		syslog( "info", "IP is not yet known" );
		goto GETIP;
	}
		
	my( $dom, $ns ) = &Nspamper::get_domdat( $name ) or next;

	my $cip = &Nspamper::get_ip( $ns, $name ) || "";
	if( ! $cip or $cip ne $wip ){
		syslog( "debug", "current IP: $cip");
		if( &Nspamper::set_ip( $ns, $dom, $key, $name, $wip ) ){
			$timeout = undef;
		} else {
			$timeout = 10;
		}
	}

GETIP:
	my $nip = &wait_newip( $timeout );
	if( $nip ){
		$wip = $nip;
		syslog( "info", "new IP: $wip");
		&write_ip( $wip );
	}
}

# remember IP for restart
sub write_ip {
	my( $ip ) = @_;

	syslog( "info", "remembering new IP");
	local *F;
	if( ! open( F, ">$ipfile") ){
		syslog( "err", "failed to write IP: $!" );
		return;
	}
	print F "$ip\n";
	close F;
}

# read stored IP on startup 
sub read_ip {
	local *F;
	open( F, $ipfile ) or return;
	my $ip = <F>;
	close F;

	chomp $ip;
	return $ip if $ip =~ /^\d+\.\d+\.\d+\.\d+$/;
	return undef;
}

# wait until we get a new IP
sub wait_newip {
	my( $timeout ) = @_;

	syslog( "debug", "waiting for IP change" ) unless $timeout;

	my $rin = '';
	vec( $rin, fileno(SOCK), 1 ) = 1;
	if( 0 >= select( $rin, undef, undef, $timeout ) ){
		return;
	}

	if( ! accept( CLIENT, SOCK) ){
		syslog( "err", "accept failed: $!" );
		return;
	}

	my $ip = <CLIENT>;
	close CLIENT;

	chomp $ip;
	return $ip if $ip =~ /^\d+\.\d+\.\d+\.\d+$/;

	syslog( "notice", "ignoring invalid IP" );
	return undef;
}


sub pidfile {
	my $file = shift;

	my $pid = $$;
	local *FH;
	if( open( FH, $file )){
		# lockfile exists!

		my $oldpid = <FH>;
		close(FH);
		chomp $oldpid;

		if( ($oldpid =~ /^\d+$/) && ! kill 0, $oldpid ){
			syslog( "info", "overriding stale lockfile");
			unlink( $file );

		} else {
			syslog( "err", "already runing with PID $oldpid");
			return;
		}
	}

	if( ! sysopen(FH, $file, O_WRONLY | O_EXCL | O_CREAT, 0600) ){
		syslog( "err", "cannot create pidfile $file: $!" );
		return;
	}

	print FH $pid, "\n";
	close FH;

	return 1;
}

=head1 FILES

/etc/nspamper.conf - config file. See commented example config for
details.

=head1 BUGS

Search the source for "TODO" to find some, but I bet there are plenty
more.

=head1 AUTHOR

Rainer Clasen

=head1 SEE ALSO

L<nspamper-change>, L<nsupdate>.

=cut

