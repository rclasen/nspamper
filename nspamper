#!/usr/bin/perl -w

=head1 NAME

nspamper - daemon to update dynamic DNS names

=head1 SYNOPSIS

 nspamper

=head1 DESCRIPTION

This is a bind9 nsupdate client to keep a dynamic A record up to date

Changes must be triggered using L<nspamper-change> which writes the new IP
to a UNIX Socket.

This daemon will retry to send the update until the Nameserver returns the
proper IP.

Once the update was successfull, this script assumes, the server won't
forget the IP and therefor sleeps until the IP is changed again.

This has to run as daemon, to avoid problems with overlapping requests. That means it gracefully accepts a new IP although the current one wasn't accepted by the nameserver.

=cut

# TODO: explain config

use strict;
use Net::DNS;
use Sys::Syslog;
use Socket;
use POSIX;

# TODO: getopt

my $prog = "nspamper";
my $ipfile = "/var/lib/misc/$prog.ip";
my $sock = "/var/run/$prog.sock";
my $pidfile = "/var/run/$prog.pid";
my $conf = "/etc/$prog.conf";

our $VERSION = "0.0.2";

# read config
-r $conf or die "missing config: $conf";
use vars qw( $name $key );
do $conf;
#$name = "warp.dyn.zuto.de";
#$key = 'blah==';

unless( $name =~ /\.(.*)/ ){
	print STDERR "invalid name: $name\n";
	exit 1;
}
my $dom = $1;



# daemonize
use vars qw( $cleanup );

my $pid = fork;
if( $pid < 0 ){
	print STDERR "fork() failed: $!\n";
	exit 1;

} elsif( $pid > 0 ){
	exit 0;
}


# TODO: close STDERR, detach tty

openlog( $prog, "pid", "daemon" );
syslog( "info", "starting" );
&pidfile( $pidfile ) or exit 1;

$cleanup++;
END {
	if( $cleanup ){
		syslog( "info", "exiting" );
		close SOCK;
		unlink $sock;
		unlink $pidfile;
	}
}

# TODO: catch SIGINT and SIGTERM

unlink $sock;
if( ! socket( SOCK, PF_UNIX, SOCK_STREAM, 0 )){
	syslog( "err", "failed to open socket: $!" );
	exit 1;
}
if( ! bind( SOCK, sockaddr_un($sock)) ){
	syslog( "err", "failed to bind socket: $!" );
	exit 1;
}
chmod( 0770, $sock );
if( ! listen( SOCK, SOMAXCONN) ){
	syslog( "err", "failedt to listen: $!");
	exit 1;
}

my $wip = &read_ip;
syslog( "debug", "old IP: $wip") if defined $wip;

my $timeout = undef;
while(1){

	if( ! $wip ){
		syslog( "info", "IP is not yet known" );
		goto GETIP;
	}
		
	my $ns = &get_nameserver( $dom ) or next;

	my $cip = &get_ip( $ns, $name ) || "";
	if( ! $cip or $cip ne $wip ){
		syslog( "debug", "current IP: $cip");
		if( &set_ip( $ns, $dom, $key, $name, $wip ) ){
			$timeout = undef;
		} else {
			$timeout = 10;
		}
	}

GETIP:
	my $nip = &wait_newip( $timeout );
	if( $nip ){
		$wip = $nip;
		syslog( "info", "new IP: $wip");
		&write_ip( $wip );
	}
}

# find nameserver responsible for a domain
sub get_nameserver {
	my( $domain ) = @_;

	my $res = new Net::DNS::Resolver;
	my $query = $res->query( $domain, "SOA" );
	if( ! $query ){
		syslog( "notice", "failed to get NS for $dom: ".
			$res->errorstring );
		return;
	}

	my $rr = ($query->answer)[0];
	if( $rr->type ne "SOA" ){
		syslog( "notice", "failed to get NS for $dom: ".
			"got non-SOA record");
		return;
	}

	my $master = $rr->mname;

	$query = $res->query( $master, "A" );
	if( ! $query ){
		syslog( "notice", "failed to get NS IP for $master: ".
			$res->errorstring );
		return;
	}
	
	$rr = ($query->answer)[0];
	if( $rr->type ne "A" ){
		syslog( "notice", "failed to get NS IP for $master: ".
			"got no A record");
		return;
	}

	return $rr->address;
}



# get current IP for a name from responsible server
sub get_ip {
	my( $ns, $name ) = @_;

	my $res = new Net::DNS::Resolver;
	$res->nameservers($ns);
	my $query = $res->query( $name, "A" );
	if( ! $query ){
		syslog( "notice", "failed to get current IP: ".
			$res->errorstring );
		return;
	}

	my $rr = ($query->answer)[0];
	if( $rr->type ne "A" ){
		syslog( "notice", "failed to get current IP: ".
			"got no A record" );
		return;
	}

	return $rr->address;
}

# update IP on server
sub set_ip {
	my( $ns, $dom, $key, $name, $ip ) = @_;

	syslog( "debug", "updating $name=$ip");

	my $upd = Net::DNS::Update->new( $dom );
	$upd->push( "update", rr_del("$name A"));
	$upd->push( "update", rr_add("$name 1 A $ip"));
	$upd->sign_tsig( $name, $key );

	my $res = Net::DNS::Resolver->new;
	$res->nameservers( $ns );
	my $rep = $res->send( $upd );
	if( defined $rep ){
		if( $rep->header->rcode ne "NOERROR" ){
			syslog( "notice", "failed to update $name: ".
				$rep->header->rcode );
			return;
		}
	} else {
		syslog( "notice", "failed to update $name: ".
			$res->errorstring );
		return;
	}

	return 1;
}

# remember IP for restart
sub write_ip {
	my( $ip ) = @_;

	syslog( "info", "remembering new IP");
	local *F;
	if( ! open( F, ">$ipfile") ){
		syslog( "err", "failed to write IP: $!" );
		return;
	}
	print F "$ip\n";
	close F;
}

# read stored IP on startup 
sub read_ip {
	local *F;
	open( F, $ipfile ) or return;
	my $ip = <F>;
	close F;

	chomp $ip;
	return $ip if $ip =~ /^\d+\.\d+\.\d+\.\d+$/;
	return undef;
}

# wait until we get a new IP
sub wait_newip {
	my( $timeout ) = @_;

	syslog( "debug", "waiting for IP change" ) unless $timeout;

	my $rin = '';
	vec( $rin, fileno(SOCK), 1 ) = 1;
	if( 0 >= select( $rin, undef, undef, $timeout ) ){
		return;
	}

	if( ! accept( CLIENT, SOCK) ){
		syslog( "err", "accept failed: $!" );
		return;
	}

	my $ip = <CLIENT>;
	close CLIENT;

	chomp $ip;
	return $ip if $ip =~ /^\d+\.\d+\.\d+\.\d+$/;

	syslog( "notice", "ignoring invalid IP" );
	return undef;
}


sub pidfile {
	my $file = shift;

	my $pid = $$;
	local *FH;
	if( open( FH, $file )){
		# lockfile exists!

		my $oldpid = <FH>;
		close(FH);
		chomp $oldpid;

		if( ($oldpid =~ /^\d+$/) && ! kill 0, $oldpid ){
			syslog( "info", "overriding stale lockfile");
			unlink( $file );

		} else {
			syslog( "err", "already runing with PID $oldpid");
			return;
		}
	}

	if( ! sysopen(FH, $file, O_WRONLY | O_EXCL | O_CREAT, 0600) ){
		syslog( "err", "cannot create pidfile $file: $!" );
		return;
	}

	print FH $pid, "\n";
	close FH;

	return 1;
}

=head1 FILES

/etc/nspamper.conf - config file. See commented example config for
details.

=head1 BUGS

Search the source for "TODO" to find some, but I bet there are plenty
more.

=head1 AUTHOR

Rainer Clasen, E<lt>rc@zuto.deE<gt>

=head1 SEE ALSO

L<nspamper-change>, L<nsupdate>.

=cut

